<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Renombrador de Facturas Marketplace by Gasti</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0f16;--card:#111827;--muted:#9aa3b2;--tx:#dbe3f2;
      --ok:#22c55e;--warn:#f59e0b;--err:#ef4444;--accent:#60a5fa
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--tx);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:980px;margin:28px auto;padding:16px}
    h1{font-size:22px;margin:0 0 6px}
    p{color:var(--muted);margin:6px 0 16px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:16px}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
    .btn{appearance:none;border:1px solid #2a3b53;background:#0f172a;color:var(--tx);
      padding:10px 14px;border-radius:10px;cursor:pointer;transition:.15s}
    .btn:hover{border-color:#3b82f6}
    .btn.primary{background:#0b2a52;border-color:#1d4ed8}
    .btn.primary:hover{background:#0a3a78}
    .btn.small{padding:6px 10px;font-size:12px}
    input[type=file]{display:none}
    label.file{border:1px dashed #3b475b;border-radius:10px;padding:12px 14px;cursor:pointer;color:var(--muted)}
    .log{max-height:420px;overflow:auto;border:1px solid #1f2937;border-radius:10px;padding:12px;background:#0c1220}
    .item{display:flex;align-items:flex-start;gap:10px;padding:10px;border-bottom:1px solid #142036}
    .item:last-child{border-bottom:0}
    .badge{font-size:11px;padding:2px 8px;border-radius:999px}
    .ok{background:#082814;color:#86efac}
    .skip{background:#231a07;color:#fcd34d}
    .err{background:#2a0a0a;color:#fca5a5}
    code{background:#0b1323;border:1px solid #1f2a42;padding:2px 6px;border-radius:6px}
    .hint{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}

    /* ===== Loader "aguantá flaca" ===== */
    .loader-backdrop{
      position:fixed;inset:0;background:rgba(8,12,20,.82);backdrop-filter: blur(2px);
      display:none;align-items:center;justify-content:center;z-index:9999
    }
    .loader{
      display:flex;flex-direction:column;gap:14px;align-items:center;
      background:#0e1729;border:1px solid #21314f;border-radius:16px;padding:24px 28px;
      box-shadow:0 8px 40px rgba(0,0,0,.35)
    }
    .spinner{
      width:46px;height:46px;border-radius:50%;
      border:4px solid #30415f;border-top-color:#8ab4ff;animation:spin 1s linear infinite
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .loader h2{margin:0;font-size:16px}
    .loader p{margin:0;font-size:13px;color:#97a5bd}
  </style>

  <!-- libs client-side -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- LOADER -->
  <div class="loader-backdrop" id="loader">
    <div class="loader" role="alert" aria-live="assertive">
      <div class="spinner" aria-hidden="true"></div>
      <h2>aguantá flaca, se está procesando…</h2>
      <p>No cierres esta pestaña. Si hay muchos PDFs puede tardar un toque.</p>
    </div>
  </div>

  <div class="wrap">
    <h1>Renombrar Facturas PDF (Cliente + Nro)</h1>
    <p>Subí varios PDFs; detectamos <em>Cliente</em> y <em>Nro</em> y te bajamos un .zip con nombres, tremendo no? Ejemplo de como quedaría: <code>Cliente - 4444-00652748.pdf</code>. YESSSS <strong>es 100% seguro</strong>.</p>

    <div class="card" style="margin-bottom:12px">
      <div class="toolbar">
        <label class="file">
          <input type="file" id="fileInput" accept="application/pdf" multiple />
          Seleccionar PDFs…
        </label>
        <button class="btn primary" id="runBtn" disabled>Procesar y descargar .zip</button>
        <button class="btn small" id="debugBtn">Ver texto extraído (1º archivo)</button>
        <span id="status" class="hint"></span>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <strong>Resultados</strong>
        <span class="hint" id="summary"></span>
      </div>
      <div id="log" class="log" aria-live="polite"></div>
      <details id="debugBox" style="margin-top:10px;display:none">
        <summary class="hint">Texto extraído (primero de la lista)</summary>
        <pre id="debugText" class="mono"></pre>
      </details>
    </div>
  </div>

  <script>
    // ====== UI helpers ======
    const $ = s => document.querySelector(s);
    const logEl = $('#log'), statusEl = $('#status'), sumEl = $('#summary');
    const runBtn = $('#runBtn'), inp = $('#fileInput'), loader = $('#loader');
    const debugBtn = $('#debugBtn'), debugBox = $('#debugBox'), debugText = $('#debugText');

    let files = [];
    inp.addEventListener('change', () => {
      files = Array.from(inp.files || []);
      runBtn.disabled = files.length === 0;
      sumEl.textContent = files.length ? `${files.length} archivos seleccionados` : '';
      logEl.innerHTML = ''; statusEl.textContent = ''; debugText.textContent = ''; debugBox.style.display='none';
    });

    debugBtn.addEventListener('click', async () => {
      if (!files.length) return;
      const dump = await extractDebugDump(files[0]);
      debugText.textContent = dump;
      debugBox.style.display = 'block';
      debugBox.open = true;
    });

    // ===== pdf.js config =====
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // ===== Utilidades =====
    const ANCHORS = [
      'iva','domicilio','cuit','c.u.i.t.','cuit/cuil/dni','c.p.','c.p.:','cta.','condiciones','fecha','hoja','factura','nro','n°','nº'
    ];
    const RE_NUM = /(\d{4})\s*[-–—]\s*(\d{6,10})/; // 4444-00652708 etc.

    const norm = s => (s||'').toLowerCase()
      .replace(/[.:;,]/g,'')
      .replace(/\s+/g,' ')
      .trim();

    function sanitize(name, maxLen=120) {
      let s = (name || '').replace(/[\\/:*?"<>|]/g, '_').replace(/\s+/g, ' ').trim();
      if (s.length > maxLen) s = s.slice(0, maxLen).trim();
      return s;
    }

    // Agrupa items por línea usando coordenada Y (tolerancia)
    function groupByLines(items, yTol=2.0) {
      const pts = items.map(it => ({str:it.str, x:it.transform[4], y:it.transform[5]}))
                       .filter(w => w.str && w.str.trim().length);
      pts.sort((a,b) => b.y - a.y || a.x - b.x); // de arriba a abajo, izq->der
      const lines = [];
      for (const w of pts) {
        let line = lines.find(L => Math.abs(L.y - w.y) <= yTol);
        if (!line) { line = { y:w.y, tokens:[] }; lines.push(line); }
        line.tokens.push({t:w.str, x:w.x});
      }
      // ordenar tokens por X
      for (const L of lines) {
        L.tokens.sort((a,b) => a.x - b.x);
        L.text = L.tokens.map(t => t.t).join(' ');
      }
      // volver arriba->abajo (ya lo está) y limpiar
      return lines;
    }

    // Tokeniza una línea en palabras conservando el X aproximado
    function explodeTokens(line) {
      const toks = [];
      for (const el of line.tokens) {
        const parts = el.t.split(/\s+/).filter(Boolean);
        for (let i=0;i<parts.length;i++) toks.push({t:parts[i], x:el.x + i*2});
      }
      return toks;
    }

    function findCliente(lines) {
      for (let i=0;i<lines.length;i++) {
        const L = lines[i];
        const toks = explodeTokens(L);
        for (let j=0;j<toks.length;j++) {
          const tok = norm(toks[j].t);
          if (tok === 'cliente') {
            // tomar lo que viene a la derecha misma línea hasta ancla
            const nameParts = [];
            for (let k=j+1; k<toks.length; k++) {
              const tk = toks[k].t;
              const n = norm(tk);
              if (n === ':' || n === '') continue;
              if (ANCHORS.includes(n) || ANCHORS.some(a => n.startsWith(a))) break;
              nameParts.push(tk);
            }
            let name = nameParts.join(' ').trim();
            // Si quedó vacío (o solo ':'), probamos en la línea siguiente
            if (!name || name === ':') {
              const next = lines[i+1];
              if (next) {
                const ntoks = explodeTokens(next);
                const nParts = [];
                for (let k=0;k<ntoks.length;k++) {
                  const nrm = norm(ntoks[k].t);
                  if (ANCHORS.includes(nrm) || ANCHORS.some(a => nrm.startsWith(a))) break;
                  nParts.push(ntoks[k].t);
                }
                name = nParts.join(' ').trim();
              }
            }
            // Limpieza: cortar si dentro asoma ancla intermedia
            name = name.replace(/\s+(IVA:|Domicilio:|CUIT[:\s]|C\.U\.I\.T\.:).*$/i,'').trim();
            if (name) return name;
          }
        }
        // fallback: la línea contiene "Cliente ..." seguido del nombre en el mismo string
        const m = /Cliente\s+(.+?)(?=\s+(IVA:|Domicilio:|CUIT|C\.U\.I\.T\.|Cta\.|C\.P\.|$))/i.exec(L.text);
        if (m && m[1]) return m[1].trim();
      }
      return null;
    }

    function findNro(lines) {
      // 1) buscar línea con etiqueta Nro / N° / Nº
      for (const L of lines) {
        const hasLabel = /\bN(?:ro|[°º])\.?\s*:?/i.test(L.text) || /\bFactura\b/i.test(L.text);
        if (hasLabel) {
          const m = RE_NUM.exec(L.text);
          if (m) return `${m[1]}-${m[2]}`;
        }
      }
      // 2) si no, buscar la primera línea con un número estilo 0000-000000
      for (const L of lines) {
        const m = RE_NUM.exec(L.text);
        if (m) return `${m[1]}-${m[2]}`;
      }
      return null;
    }

    async function parseOneFile(file, dumpFirst=false) {
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      let allText = [];
      let linesAll = [];
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const tc = await page.getTextContent();
        const lines = groupByLines(tc.items);
        linesAll.push(...lines);
        allText.push(lines.map(L => L.text).join('\n'));
      }
      const cliente = findCliente(linesAll);
      const nro = findNro(linesAll);
      const dump = allText.join('\n');

      if (dumpFirst) {
        debugText.textContent = dump;
        debugBox.style.display = 'block';
        debugBox.open = true;
      }
      return { cliente, nro };
    }

    async function extractDebugDump(file) {
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      let out = [];
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const tc = await page.getTextContent();
        const lines = groupByLines(tc.items);
        out.push(lines.map(L => L.text).join('\n'));
      }
      return out.join('\n');
    }

    function logRow(type, original, message) {
      const div = document.createElement('div');
      div.className = 'item';
      const badge = document.createElement('span');
      badge.className = 'badge ' + (type==='ok'?'ok':type==='skip'?'skip':'err');
      badge.textContent = type === 'ok' ? 'OK' : type === 'skip' ? 'SIN CAMBIOS' : 'ERROR';
      const content = document.createElement('div');
      content.innerHTML = `<div><strong>${original}</strong></div><div class="hint">${message}</div>`;
      div.appendChild(badge); div.appendChild(content);
      logEl.appendChild(div); logEl.scrollTop = logEl.scrollHeight;
    }

    // ===== Proceso principal =====
    async function processAll() {
      if (!files.length) return;

      // Loader ON
      loader.style.display = 'flex';
      runBtn.disabled = true; logEl.innerHTML = ''; statusEl.textContent = 'Leyendo PDFs…'; sumEl.textContent = '';

      let ok = 0, fail = 0, dumped = false;
      const zip = new JSZip();

      for (const f of files) {
        try {
          const { cliente, nro } = await parseOneFile(f, !dumped);
          dumped = true;

          if (!cliente || !nro) {
            fail++; logRow('skip', f.name, 'No se pudo extraer Cliente y/o Nro (¿PDF escaneado?)');
            continue;
          }
          const newName = `${sanitize(cliente)} - ${sanitize(nro)}.pdf`;
          const ab = await f.arrayBuffer();
          zip.file(newName, ab);
          ok++; logRow('ok', f.name, `→ ${newName}`);
        } catch (e) {
          fail++; logRow('err', f.name, String(e));
        }
      }

      const total = ok + fail;
      sumEl.textContent = `Resumen: ${ok} OK, ${fail} sin cambios/errores, total ${total}.`;

      if (ok > 0) {
        statusEl.textContent = 'Comprimiendo ZIP…';
        const blob = await zip.generateAsync({type:'blob'});
        saveAs(blob, `facturas_renombradas_${new Date().toISOString().slice(0,10)}.zip`);
        statusEl.textContent = 'Listo ✅';
      } else {
        statusEl.textContent = 'Sin archivos renombrados.';
      }

      // Loader OFF
      loader.style.display = 'none';
      runBtn.disabled = files.length === 0;
    }

    runBtn.addEventListener('click', processAll);
  </script>
</body>
</html>
